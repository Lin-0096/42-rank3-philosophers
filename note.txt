pthread_mutex_t：
A mutex is used to prevent data races — to make sure only one thread accesses a critical section of code at a time.
It's like a lock that a thread must "acquire" before accessing shared data

example：
pthread_mutex_t	lock;
pthread_mutex_init(&lock, NULL);      // Initialize the lock
pthread_mutex_lock(&lock);            // Lock it (enter critical section)
// do something shared here
pthread_mutex_unlock(&lock);          // Unlock (leave critical section)
-----------------------------
pthread_t：
the data type used to represent a thread.
think of it like a "handle" or "ID" to a thread.
When create a new thread using pthread_create(), you pass a pthread_t variable to keep track of that thread.
::
int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg)   //Creates a new thread of execution.

int pthread_detach(pthread_t thread)   //Marks a thread for deletion.

int pthread_join(pthread_t thread, void **value_ptr)   //Causes the calling thread to wait for the termination of the specified thread.
--------------------------------
long	get_current_time(void)
{
	struct timeval	tv;

	gettimeofday(&tv, NULL); //fills the tv struct with the current system time
	return (tv.tv_sec * 1000L + tv.tv_usec / 1000);
	//1000L ensures the result is a long to avoid overflow.
	//convert seconds to milliseconds. convert microseconds to milliseconds. return total time then
}

struct timeval {
    time_t      tv_sec; // seconds(start from 1.1.1970从1970)
    suseconds_t tv_usec;//microseconds(0 ~ 999999)
};
---------------------------------
!!!!!test if the program has data race:
example:
valgrind --tool=helgrind ./philo 5 800 200 200

---------------------
usleep: suspend thread execution for an interval measured in microseconds
1000 microseconds = 1 milliseconds

--------------
// if (philo->eat_count > 0 && philo->eat_count >= philo->data->num_must_eat) //should i check eat_count and protect eat_count??
// {
// 	print_status(philo, "has eaten the maximum number of times");
// 	break ;
// }
--------------------
!!!! wrong: usleep(usleep(philo->data->time_to_eat * 1000);)

The main reason is that both the eating and sleeping functions use a single, long usleep to wait out the full eating or sleeping period, without checking the death flag during that time. If a philosopher is supposed to “stop” (because someone has died) while they're still sleeping or eating, they won’t notice it—they’ll just continue eating or sleeping until the time is up. Meanwhile, your monitor thread may notice that their last_mealtime hasn’t been updated in time and will mark them as dead.
------------
remember to add usleep(1000) in both routines

usleep(1000)
1\Prevents 100% CPU Usage:
Without a small sleep inside the philosopher's infinite loop, the thread would run as fast as possible, using up all available CPU. This is called “busy-waiting,” and it's very inefficient.

2\Gives Other Threads a Chance:
By adding a small usleep, you tell the thread to “pause” for 1 millisecond (1000 microseconds) at the end of each loop. This allows the operating system to schedule other threads (like other philosophers and the monitor), making your program more efficient and fair.

3\Makes Timing More Predictable:
It smooths out the loop, preventing it from spamming actions or log messages thousands of times per second, which would be unrealistic in the context of the philosopher simulation.
